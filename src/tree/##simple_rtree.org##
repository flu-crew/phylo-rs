So the simple_rtree "trait" does the following
gives a basic implementation for all rooted trees

A tree in the basic sense must have
A node value that can be hashed
A way to represent the edges between nodes : Do we allow flexibility here?


Idea:
Node only contains data associated only with that node
Edge is any collection of two nodes


So
Node must implement Hash,PartialEq
Edge must implement PartialEq

A tree in the basic sense must have
a list of nodes
a list of edges


pub trait SimpleTree{
    type Node = Hash + Debug + PartialEq
    type Edge = Debug + PartialEq
    type EdgeWeight
    fn add_node(&mut self) -> Rc<Node>;
    fn add_edge(&mut self, node1:Node, node2:Node, distance:Option<EdgeWeight>) -> Edge
    fn remove_node(&mut self, node:Node) -> Rc<Node>
    fn remove_edge(&mut self,edge:Edge) -> Rc<Edge>
    fn set_edge_weight(&mut self, edge:Edge, distance:Option<EdgeWeight>);
}

pub trait SimpleRTree : SimpleTree {
    fn set_child(&mut self, parent:Rc<Node>, child:Rc<Node>, distance:Option<EdgeWeight>) -> bool;
    fn set_leaf(&mut self, node:Rc<Node>);
    fn get_root(&self) -> Rc<Node>;
} 